# Курсовая работа: Многопоточное и асинхронное программирование на Java. Custom Thread Pool.

## Описание
Данная работа представляет реализацию кастомного пула потоков, который поддерживает гибкую настройку параметров, распределение задач, обработку отказов и логирование. Реализация направлена на демонстрацию ключевых аспектов многопоточного программирования в Java.

## Основные функции
1. **Настраиваемые параметры пула:**
   - `corePoolSize` — минимальное количество потоков.
   - `maxPoolSize` — максимальное количество потоков.
   - `queueSize` — максимальное количество задач в очереди.
   - `keepAliveTime` — время ожидания перед завершением неактивного потока.
   - `minSpareThreads` — минимальное количество резервных потоков.

2. **Обработка отказов:**
   - Используется интерфейс `CustomRejectedExecutionHandler`, который обрабатывает задачи, отклоненные из-за переполнения очереди.

3. **Распределение задач:**
   - Задачи распределяются равномерно между потоками с учетом доступности.
   - Реализован алгоритм Round Robin для распределения задач между несколькими очередями в `CustomThreadPoolWithRoundRobin`.

4. **Логирование событий:**
   - Все ключевые события фиксируются в логах, включая:
     - Создание и завершение потоков.
     - Добавление задач в очередь.
     - Выполнение задач.
     - Обработка отказов.
     - Завершение работы пула.

## Демонстрация
В файле `Main.java` представлены примеры использования пула потоков:
1. Отправка нескольких задач в пул.
2. Демонстрация обработки переполнения очереди.
3. Корректное завершение работы пула и ожидание выполнения всех задач.

### Пример использования
```java
// Инициализируем пул потоков
CustomThreadPool threadPool = new CustomThreadPool(
    2, // corePoolSize
    4, // maxPoolSize
    5, // queueSize
    5, // keepAliveTime (в секундах)
    1  // minSpareThreads
);

// Отправляем задачи
for (int i = 0; i < 10; i++) {
    int taskId = i;
    threadPool.execute(() -> {
        System.out.println("[Task-" + taskId + "] Начало выполнения");
        try {
            Thread.sleep(2000); // Имитируем выполнение задачи
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        System.out.println("[Task-" + taskId + "] Завершение выполнения");
    });
}

// Завершаем работу
threadPool.shutdown();
```

### Пример вывода логов
```text
[ThreadFactory] Creating new thread: MyPool-worker-1
[ThreadFactory] Creating new thread: MyPool-worker-2
[Task-1] Начало выполнения
[Task-2] Начало выполнения
[Rejected] Task was rejected due to overload!
[Task-1] Завершение выполнения
[Task-2] Завершение выполнения
[Worker] MyPool-worker-1 idle timeout, stopping.
```

## Отчет

### 1. Анализ производительности
#### Наш кастомный пул потоков:
- **Преимущества:**
  - Гибкость в настройке параметров.
  - Возможность кастомизации логики распределения задач.
  - Логирование всех ключевых событий.

- **Недостатки:**
  - Производительность ниже стандартных решений в обычных сценариях.
  - Требует больше времени на разработку и тестирование.

#### Стандартный `ThreadPoolExecutor`:
- **Преимущества:**
  - Высокая производительность.
  - Оптимизация для большинства стандартных задач.
  - Простота в использовании.

- **Недостатки:**
  - Ограниченная кастомизация.

### 2. Оптимальные параметры пула
На основе тестов и экспериментов:
- **Размер пула потоков (`corePoolSize`, `maxPoolSize`):** Увеличение `corePoolSize` улучшает производительность при многозадачности, но увеличивает расход ресурсов.
- **Длина очереди (`queueSize`):** Оптимальное значение зависит от интенсивности задач. Для теста с 10 задачами рекомендовано значение `queueSize = 10`.
- **Время ожидания (`keepAliveTime`):** Установка небольшого времени помогает быстрее освобождать ресурсы.

**Рекомендации:** 
- `corePoolSize = 4`, `maxPoolSize = 10`, `queueSize = 20`, `keepAliveTime = 5`.

### 3. Принцип распределения задач
- Задачи распределяются через очередь `ArrayBlockingQueue`.
- Для `CustomThreadPoolWithRoundRobin` используется алгоритм Round Robin, который равномерно распределяет задачи между очередями потоков.

Пример реализации Round Robin:
```java
int index = roundRobinIndex.getAndIncrement() % taskQueues.length;
BlockingQueue<Runnable> targetQueue = taskQueues[index];
if (!targetQueue.offer(command)) {
    getRejectedHandler().rejectedExecution(command, this);
} else {
    ensureWorkerThreads();
}
```

## Заключение
Реализация кастомного пула потоков демонстрирует гибкость и надежность, что делает его подходящим для проектов среднего масштаба. Для повышения производительности рекомендуется провести дополнительные тесты под реальными нагрузками.
