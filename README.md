# Курсовая работа: Многопоточное и асинхронное программирование на Java. Custom Thread Pool.

## Описание
Данная работа представляет реализацию кастомного пула потоков, который поддерживает гибкую настройку параметров, распределение задач, обработку отказов и логирование. Реализация направлена на демонстрацию ключевых аспектов многопоточного программирования в Java.

## Основные функции
1. **Настраиваемые параметры пула:**
   - `corePoolSize` — минимальное количество потоков.
   - `maxPoolSize` — максимальное количество потоков.
   - `queueSize` — максимальное количество задач в очереди.
   - `keepAliveTime` — время ожидания перед завершением неактивного потока.
   - `minSpareThreads` — минимальное количество резервных потоков.

2. **Обработка отказов:**
   - Используется интерфейс `CustomRejectedExecutionHandler`, который обрабатывает задачи, отклоненные из-за переполнения очереди. 

3. **Распределение задач:**
   - Задачи распределяются равномерно между потоками с учетом доступности.

4. **Логирование событий:**
   - Все ключевые события фиксируются в логах, включая:
     - Создание и завершение потоков.
     - Добавление задач в очередь.
     - Выполнение задач.
     - Обработка отказов.
     - Завершение работы пула.

## Демонстрация
В файле `Main.java` представлены примеры использования пула потоков:
1. Отправка нескольких задач в пул.
2. Демонстрация обработки переполнения очереди.
3. Корректное завершение работы пула и ожидание выполнения всех задач.

### Пример использования
```java
// Инициализируем пул потоков
CustomThreadPool threadPool = new CustomThreadPool(
    2, // corePoolSize
    4, // maxPoolSize
    5, // queueSize
    5, // keepAliveTime (в секундах)
    1  // minSpareThreads
);

// Отправляем задачи
for (int i = 0; i < 10; i++) {
    int taskId = i;
    threadPool.execute(() -> {
        System.out.println("[Task-" + taskId + "] Начало выполнения");
        try {
            Thread.sleep(2000); // Имитируем выполнение задачи
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        System.out.println("[Task-" + taskId + "] Завершение выполнения");
    });
}

// Завершаем работу
threadPool.shutdown();
```

### Пример вывода логов
```text
[ThreadFactory] Creating new thread: MyPool-worker-1
[ThreadFactory] Creating new thread: MyPool-worker-2
[Task-1] Начало выполнения
[Task-2] Начало выполнения
[Rejected] Task was rejected due to overload!
[Task-1] Завершение выполнения
[Task-2] Завершение выполнения
[Worker] MyPool-worker-1 idle timeout, stopping.
```

## Сравнение производительности
### Наш кастомный пул потоков:
- **Преимущества:**
  - Гибкость в настройке параметров.
  - Возможность кастомизации логики распределения задач.
  - Логирование всех ключевых событий.

- **Недостатки:**
  - Производительность ниже стандартных решений в обычных сценариях.
  - Требует больше времени на разработку и тестирование.

### Стандартный `ThreadPoolExecutor`:
- **Преимущества:**
  - Высокая производительность.
  - Оптимизация для большинства стандартных задач.
  - Простота в использовании.

- **Недостатки:**
  - Ограниченная кастомизация.

## Заключение
Реализация кастомного пула потоков позволяет гибко управлять задачами и потоками, что может быть полезно в высоконагруженных приложениях, где стандартные решения не подходят. Однако для большинства приложений лучше использовать стандартные библиотеки, такие как `ThreadPoolExecutor`.

## Сборка и запуск
1. Скомпилируйте проект:
   ```bash
   javac CustomThreadPool.java Main.java
   ```
2. Запустите демонстрационную программу:
   ```bash
   java Main
   ```

## Файлы проекта
- `CustomThreadPool.java` — реализация пула потоков.
- `Main.java` — демонстрационная программа.
- `README.md` — отчет и документация.
